// Tennis Paris Listener - Search Configuration App

// Constants for tennis.paris.fr API
// Court surface types (selCoating): 96=Clay, 2095=Hard, 94=Synthetic, 1324=Carpet, 2016=Grass, 92=Other
// Indoor/Outdoor (selInOut): V=Outdoor (Vert/Green), F=Indoor (Ferm√©/Closed)
const API_COATING_TYPES = ['96', '2095', '94', '1324', '2016', '92'];
const API_IN_OUT_TYPES = ['V', 'F'];

// CORS proxy URL - can be set to null to disable proxy
// Using AllOrigins as a free CORS proxy service
// Note: Most free CORS proxies only support GET requests, so this may not work
// for POST endpoints. The code falls back to direct requests if the proxy fails.
const CORS_PROXY = 'https://api.allorigins.win/raw?url=';

// Fallback facilities data (used if API call fails due to CORS or network issues)
// Generated by scripts/fetch-facilities.js
const FALLBACK_FACILITIES = {
    "Alain Mimoun": [
        {number: 1, covered: true},
        {number: 2, covered: true},
        {number: 3, covered: true},
        {number: 4, covered: false},
        {number: 5, covered: false},
        {number: 6, covered: false}
    ],
    "Amandiers": [
        {number: 2, covered: false}
    ],
    "Atlantique": [
        {number: 1, covered: false},
        {number: 2, covered: false},
        {number: 3, covered: false},
        {number: 4, covered: false},
        {number: 5, covered: false}
    ],
    "Aurelle de Paladines": [
        {number: 1, covered: false},
        {number: 2, covered: false},
        {number: 3, covered: false}
    ],
    "Bertrand Dauvin": [
        {number: 1, covered: true},
        {number: 2, covered: true},
        {number: 3, covered: true}
    ],
    "Bobigny": [
        {number: 1, covered: false},
        {number: 2, covered: false},
        {number: 3, covered: false},
        {number: 4, covered: false},
        {number: 5, covered: false},
        {number: 6, covered: false},
        {number: 7, covered: false},
        {number: 8, covered: false}
    ],
    "Broquedis - Asni√®res": [
        {number: 1, covered: false},
        {number: 2, covered: false},
        {number: 3, covered: false},
        {number: 4, covered: false},
        {number: 5, covered: false},
        {number: 6, covered: false},
        {number: 7, covered: false},
        {number: 8, covered: false},
        {number: 9, covered: false}
    ],
    "Candie": [
        {number: 1, covered: false},
        {number: 2, covered: false}
    ],
    "Carnot": [
        {number: 1, covered: true},
        {number: 2, covered: true},
        {number: 3, covered: true}
    ],
    "Ch√¢teau des Rentiers": [
        {number: 1, covered: false}
    ],
    "Cordeli√®res": [
        {number: 1, covered: false},
        {number: 2, covered: false}
    ],
    "Croix Nivert": [
        {number: 1, covered: false}
    ],
    "Docteurs D√©jerine": [
        {number: 1, covered: true},
        {number: 2, covered: true}
    ],
    "Dunois": [
        {number: 1, covered: false},
        {number: 2, covered: false}
    ],
    "Edouard Pailleron": [
        {number: 1, covered: true},
        {number: 2, covered: true}
    ],
    "Elisabeth": [
        {number: 1, covered: true},
        {number: 2, covered: true},
        {number: 3, covered: false},
        {number: 4, covered: false},
        {number: 5, covered: false},
        {number: 6, covered: true},
        {number: 7, covered: true},
        {number: 8, covered: true},
        {number: 9, covered: true}
    ],
    "Georges Carpentier": [
        {number: 1, covered: true},
        {number: 2, covered: true}
    ],
    "Halle Fret": [
        {number: 1, covered: false},
        {number: 2, covered: false}
    ],
    "Henry de Montherlant": [
        {number: 1, covered: false},
        {number: 2, covered: false},
        {number: 3, covered: false},
        {number: 4, covered: false},
        {number: 5, covered: false},
        {number: 6, covered: false},
        {number: 7, covered: false}
    ],
    "Jandelle": [
        {number: 1, covered: false}
    ],
    "Jesse Owens": [
        {number: 1, covered: false},
        {number: 2, covered: false},
        {number: 3, covered: false}
    ],
    "Jules Ladoum√®gue": [
        {number: 1, covered: true},
        {number: 2, covered: true},
        {number: 3, covered: true},
        {number: 4, covered: true},
        {number: 5, covered: true},
        {number: 6, covered: true},
        {number: 7, covered: true},
        {number: 8, covered: true}
    ],
    "La Falu√®re": [
        {number: 1, covered: false},
        {number: 2, covered: false},
        {number: 3, covered: false},
        {number: 4, covered: false},
        {number: 5, covered: false},
        {number: 6, covered: false},
        {number: 7, covered: false},
        {number: 8, covered: false},
        {number: 9, covered: false},
        {number: 10, covered: false},
        {number: 11, covered: false},
        {number: 12, covered: false},
        {number: 13, covered: false},
        {number: 14, covered: false},
        {number: 15, covered: false},
        {number: 16, covered: false},
        {number: 17, covered: false},
        {number: 18, covered: false},
        {number: 19, covered: false},
        {number: 20, covered: false},
        {number: 21, covered: false}
    ],
    "L√©o Lagrange": [
        {number: 1, covered: false},
        {number: 2, covered: false},
        {number: 3, covered: false},
        {number: 4, covered: false},
        {number: 5, covered: false},
        {number: 6, covered: false}
    ],
    "Max Rousi√©": [
        {number: 1, covered: true},
        {number: 2, covered: true},
        {number: 3, covered: true}
    ],
    "Moureu - Baudricourt": [
        {number: 1, covered: true},
        {number: 2, covered: true},
        {number: 3, covered: true},
        {number: 4, covered: false}
    ],
    "NEUVE SAINT PIERRE": [
        {number: 1, covered: true}
    ],
    "Niox": [
        {number: 1, covered: false},
        {number: 2, covered: true},
        {number: 3, covered: true},
        {number: 4, covered: false}
    ],
    "Padel Jules Ladoum√®gue": [
        {number: 1, covered: true},
        {number: 2, covered: true},
        {number: 3, covered: true},
        {number: 4, covered: true},
        {number: 5, covered: true},
        {number: 6, covered: true},
        {number: 7, covered: true},
        {number: 8, covered: true}
    ],
    "Paul Barruel": [
        {number: 1, covered: false}
    ],
    "Philippe Auguste": [
        {number: 1, covered: false}
    ],
    "Poissonniers": [
        {number: 1, covered: false},
        {number: 2, covered: false},
        {number: 3, covered: false}
    ],
    "Poliveau": [
        {number: 1, covered: true}
    ],
    "Poterne des Peupliers": [
        {number: 1, covered: true},
        {number: 2, covered: true}
    ],
    "Puteaux": [
        {number: 1, covered: false},
        {number: 2, covered: false},
        {number: 3, covered: false},
        {number: 4, covered: false},
        {number: 5, covered: false},
        {number: 6, covered: false},
        {number: 7, covered: false},
        {number: 8, covered: false},
        {number: 9, covered: false},
        {number: 10, covered: false},
        {number: 11, covered: false},
        {number: 12, covered: false},
        {number: 13, covered: false},
        {number: 14, covered: false},
        {number: 15, covered: false},
        {number: 16, covered: false},
        {number: 17, covered: false},
        {number: 18, covered: false},
        {number: 19, covered: false},
        {number: 20, covered: false},
        {number: 21, covered: false},
        {number: 22, covered: false},
        {number: 23, covered: false},
        {number: 24, covered: false}
    ],
    "Ren√© et Andr√© Mourlon": [
        {number: 1, covered: false},
        {number: 2, covered: false},
        {number: 3, covered: false}
    ],
    "Ren√©e Garilhe - ex Courcelles": [
        {number: 1, covered: false},
        {number: 2, covered: false},
        {number: 3, covered: false},
        {number: 4, covered: false}
    ],
    "Rigoulot - La Plaine": [
        {number: 1, covered: true},
        {number: 2, covered: true},
        {number: 3, covered: true},
        {number: 4, covered: false},
        {number: 5, covered: false},
        {number: 6, covered: false},
        {number: 7, covered: false}
    ],
    "Sablonni√®re": [
        {number: 1, covered: false}
    ],
    "Sept arpents": [
        {number: 1, covered: true},
        {number: 2, covered: true},
        {number: 3, covered: false}
    ],
    "Suzanne Lenglen": [
        {number: 1, covered: false},
        {number: 2, covered: false},
        {number: 3, covered: false},
        {number: 4, covered: false},
        {number: 5, covered: false},
        {number: 6, covered: false},
        {number: 7, covered: false},
        {number: 8, covered: false},
        {number: 9, covered: false},
        {number: 10, covered: false},
        {number: 11, covered: true},
        {number: 12, covered: true},
        {number: 13, covered: false}
    ],
    "Thi√©r√©": [
        {number: 1, covered: false}
    ],
    "Valeyre": [
        {number: 1, covered: false}
    ]
};

// State
let searches = [];
let courtIdCounter = 0;
let facilitiesData = FALLBACK_FACILITIES; // Use fallback data directly

// Initialize app
document.addEventListener('DOMContentLoaded', () => {
    loadSearches();
    renderSavedSearches();
    updateExportSelect();
    setupEventListeners();
    addCourtField(); // Add one court field by default
    setDefaultDate();
});

// Set default date to tomorrow
function setDefaultDate() {
    const tomorrow = new Date();
    tomorrow.setDate(tomorrow.getDate() + 1);
    
    // Format date as YYYY-MM-DD for input[type="date"]
    const year = tomorrow.getFullYear();
    const month = String(tomorrow.getMonth() + 1).padStart(2, '0');
    const day = String(tomorrow.getDate()).padStart(2, '0');
    
    document.getElementById('whenDate').value = `${year}-${month}-${day}`;
}

// Setup event listeners
function setupEventListeners() {
    document.getElementById('addCourtBtn').addEventListener('click', addCourtField);
    document.getElementById('saveBtn').addEventListener('click', saveSearch);
    document.getElementById('clearBtn').addEventListener('click', clearForm);
    document.getElementById('exportBtn').addEventListener('click', exportToEnv);
}

// Add court field
function addCourtField() {
    const courtId = courtIdCounter++;
    const container = document.getElementById('courtsContainer');
    
    const courtDiv = document.createElement('div');
    courtDiv.className = 'court-item';
    courtDiv.dataset.courtId = courtId;
    
    // Get sorted facility names
    const facilityNames = Object.keys(facilitiesData).sort();
    
    let facilityOptionsHtml = '<option value="">-- Select a facility --</option>';
    facilityNames.forEach(name => {
        facilityOptionsHtml += `<option value="${escapeHtml(name)}">${escapeHtml(name)}</option>`;
    });
    
    // If no facilities loaded, provide text input fallback
    const facilitySelectHtml = facilityNames.length > 0 
        ? `<select class="court-name" data-court-id="${courtId}">${facilityOptionsHtml}</select>`
        : `<input type="text" placeholder="Tennis facility name (e.g., La Falu√®re)" class="court-name" data-court-id="${courtId}">`;
    
    courtDiv.innerHTML = `
        <div class="court-header">
            ${facilitySelectHtml}
            <button type="button" class="btn-remove" data-court-id="${courtId}">Remove</button>
        </div>
        <div class="court-numbers">
            <label>Court numbers:</label>
            <div class="court-numbers-container" data-court-id="${courtId}">
                <p class="court-numbers-hint">Select a facility to see available courts</p>
            </div>
        </div>
    `;
    
    container.appendChild(courtDiv);
    
    // Attach event listeners programmatically
    const facilityInput = courtDiv.querySelector('.court-name');
    if (facilityInput) {
        facilityInput.addEventListener('change', () => updateCourtNumbers(courtId));
    }
    
    const removeBtn = courtDiv.querySelector('.btn-remove');
    if (removeBtn) {
        removeBtn.addEventListener('click', () => removeCourtField(courtId));
    }
}

// Update court numbers display when facility is selected
function updateCourtNumbers(courtId) {
    const facilitySelect = document.querySelector(`.court-name[data-court-id="${courtId}"]`);
    const courtNumbersContainer = document.querySelector(`.court-numbers-container[data-court-id="${courtId}"]`);
    
    if (!facilitySelect || !courtNumbersContainer) return;
    
    const facilityName = facilitySelect.value.trim();
    
    if (!facilityName) {
        courtNumbersContainer.innerHTML = '<p class="court-numbers-hint">Select a facility to see available courts</p>';
        return;
    }
    
    const courtNumbers = facilitiesData[facilityName];
    
    if (!courtNumbers || courtNumbers.length === 0) {
        courtNumbersContainer.innerHTML = '<p class="court-numbers-hint">No court information available for this facility</p>';
        return;
    }
    
    // Create checkboxes for each court number
    let html = `<div class="court-checkboxes">
        <label class="select-all-label">
            <input type="checkbox" class="select-all-courts" data-court-id="${courtId}">
            Select All
        </label>
        <div class="court-checkboxes-grid">`;
    
    courtNumbers.forEach(court => {
        const coveredIcon = court.covered ? '‚òÇÔ∏è' : '';
        const coveredClass = court.covered ? 'covered' : '';
        html += `
            <label class="court-checkbox-label ${coveredClass}">
                <input type="checkbox" class="court-checkbox" data-court-id="${courtId}" value="${court.number}">
                ${coveredIcon} Court ${court.number}
            </label>
        `;
    });
    
    html += '</div></div>';
    courtNumbersContainer.innerHTML = html;
    
    // Attach Select All event listener
    const selectAllCheckbox = courtNumbersContainer.querySelector('.select-all-courts');
    if (selectAllCheckbox) {
        selectAllCheckbox.addEventListener('change', () => toggleAllCourts(courtId));
    }
}

// Toggle all courts selection
function toggleAllCourts(courtId) {
    const selectAllCheckbox = document.querySelector(`.select-all-courts[data-court-id="${courtId}"]`);
    const courtCheckboxes = document.querySelectorAll(`.court-checkbox[data-court-id="${courtId}"]`);
    
    courtCheckboxes.forEach(checkbox => {
        checkbox.checked = selectAllCheckbox.checked;
    });
}

// Remove court field
function removeCourtField(courtId) {
    const courtDiv = document.querySelector(`[data-court-id="${courtId}"]`);
    if (courtDiv) {
        courtDiv.remove();
    }
}

// Save search
function saveSearch() {
    const searchName = document.getElementById('searchName').value.trim();
    
    if (!searchName) {
        showMessage('Please enter a search name', 'error');
        return;
    }
    
    // Get date from date picker (format: YYYY-MM-DD)
    const dateValue = document.getElementById('whenDate').value;
    
    if (!dateValue) {
        showMessage('Please select a date', 'error');
        return;
    }
    
    // Parse the date value
    const [whenYear, whenMonth, whenDay] = dateValue.split('-').map(num => parseInt(num, 10));
    
    if (!whenDay || !whenMonth || !whenYear) {
        showMessage('Please enter a valid date', 'error');
        return;
    }
    
    // Get time range
    const hourRangeStart = parseInt(document.getElementById('hourRangeStart').value);
    const hourRangeEnd = parseInt(document.getElementById('hourRangeEnd').value);
    
    // Get options
    const coveredOnly = document.getElementById('coveredOnly').checked;
    const twoHours = document.getElementById('twoHours').checked;
    
    // Get courts
    const courtElements = document.querySelectorAll('.court-name');
    const courts = [];
    
    courtElements.forEach(courtEl => {
        const name = courtEl.value.trim();
        if (name) {
            const courtId = courtEl.dataset.courtId;
            
            // Get selected court numbers from checkboxes
            const checkedCheckboxes = document.querySelectorAll(`.court-checkbox[data-court-id="${courtId}"]:checked`);
            const numbers = Array.from(checkedCheckboxes).map(cb => parseInt(cb.value)).filter(n => !isNaN(n));
            
            courts.push({
                name: name,
                numbers: numbers
            });
        }
    });
    
    if (courts.length === 0) {
        showMessage('Please add at least one tennis facility', 'error');
        return;
    }
    
    // Create search object
    const search = {
        id: Date.now(),
        name: searchName,
        whenDay,
        whenMonth,
        whenYear,
        hourRangeStart,
        hourRangeEnd,
        coveredOnly,
        twoHours,
        courts,
        createdAt: new Date().toISOString()
    };
    
    // Save to array
    searches.push(search);
    saveSearches();
    renderSavedSearches();
    updateExportSelect();
    clearForm();
    
    showMessage('Search saved successfully!', 'success');
}

// Clear form
function clearForm() {
    document.getElementById('searchName').value = '';
    document.getElementById('coveredOnly').checked = false;
    document.getElementById('twoHours').checked = false;
    
    // Clear all court fields
    document.getElementById('courtsContainer').innerHTML = '';
    courtIdCounter = 0;
    addCourtField();
    
    setDefaultDate();
}

// Load search into form
function loadSearchIntoForm(searchId) {
    const search = searches.find(s => s.id === searchId);
    if (!search) return;
    
    document.getElementById('searchName').value = search.name;
    
    // Format date for input[type="date"] (YYYY-MM-DD)
    const year = search.whenYear;
    const month = String(search.whenMonth).padStart(2, '0');
    const day = String(search.whenDay).padStart(2, '0');
    document.getElementById('whenDate').value = `${year}-${month}-${day}`;
    
    document.getElementById('hourRangeStart').value = search.hourRangeStart;
    document.getElementById('hourRangeEnd').value = search.hourRangeEnd;
    document.getElementById('coveredOnly').checked = search.coveredOnly;
    document.getElementById('twoHours').checked = search.twoHours;
    
    // Clear and add courts
    document.getElementById('courtsContainer').innerHTML = '';
    courtIdCounter = 0;
    
    search.courts.forEach(court => {
        addCourtField();
        const lastCourtId = courtIdCounter - 1;
        const courtNameInput = document.querySelector(`.court-name[data-court-id="${lastCourtId}"]`);
        
        if (courtNameInput) {
            courtNameInput.value = court.name;
            // Trigger update to show court checkboxes
            updateCourtNumbers(lastCourtId);
            
            // Wait for checkboxes to be rendered before checking them
            requestAnimationFrame(() => {
                court.numbers.forEach(num => {
                    const checkbox = document.querySelector(`.court-checkbox[data-court-id="${lastCourtId}"][value="${num}"]`);
                    if (checkbox) {
                        checkbox.checked = true;
                    }
                });
            });
        }
    });
    
    window.scrollTo({ top: 0, behavior: 'smooth' });
}

// Delete search
function deleteSearch(searchId) {
    if (confirm('Are you sure you want to delete this search?')) {
        searches = searches.filter(s => s.id !== searchId);
        saveSearches();
        renderSavedSearches();
        updateExportSelect();
        showMessage('Search deleted successfully', 'success');
    }
}

// Render saved searches
function renderSavedSearches() {
    const container = document.getElementById('savedSearches');
    
    if (searches.length === 0) {
        container.innerHTML = '<p class="empty-state">No saved searches yet. Create one above!</p>';
        return;
    }
    
    container.innerHTML = searches.map(search => `
        <div class="saved-search">
            <div class="saved-search-header">
                <h3>${escapeHtml(search.name)}</h3>
                <div class="saved-search-actions">
                    <button class="btn-primary" onclick="executeQuery(${search.id})">Test Query</button>
                    <button class="btn-secondary" onclick="loadSearchIntoForm(${search.id})">Edit</button>
                    <button class="btn-danger" onclick="deleteSearch(${search.id})">Delete</button>
                </div>
            </div>
            <div class="saved-search-details">
                <p><strong>Date:</strong> ${search.whenDay}/${search.whenMonth}/${search.whenYear}</p>
                <p><strong>Time:</strong> ${search.hourRangeStart}:00 - ${search.hourRangeEnd}:00</p>
                <p><strong>Facilities:</strong> ${search.courts.map(c => {
                    let text = c.name;
                    if (c.numbers.length > 0) {
                        text += ` (courts: ${c.numbers.join(', ')})`;
                    }
                    return text;
                }).join('; ')}</p>
                ${search.coveredOnly ? '<p><strong>‚úì</strong> Covered courts only</p>' : ''}
                ${search.twoHours ? '<p><strong>‚úì</strong> Looking for 2 consecutive hours</p>' : ''}
            </div>
            <div id="results-${search.id}" class="query-results"></div>
        </div>
    `).join('');
}

// Update export select dropdown
function updateExportSelect() {
    const select = document.getElementById('exportSelect');
    select.innerHTML = '<option value="">-- Select a search --</option>' + 
        searches.map(s => `<option value="${s.id}">${escapeHtml(s.name)}</option>`).join('');
}

// Export to .env format
function exportToEnv() {
    const selectEl = document.getElementById('exportSelect');
    const searchId = parseInt(selectEl.value);
    
    if (!searchId) {
        showMessage('Please select a search to export', 'error');
        return;
    }
    
    const search = searches.find(s => s.id === searchId);
    if (!search) return;
    
    // Generate .env content
    let envContent = '# Configuration for tennis.paris.fr-listener\n';
    envContent += `# Generated from search: ${search.name}\n\n`;
    
    // Basic fields
    envContent += `# Date to check (DD/MM/YYYY format)\n`;
    envContent += `WHEN_DAY=${search.whenDay}\n`;
    envContent += `WHEN_MONTH=${search.whenMonth}\n`;
    envContent += `WHEN_YEAR=${search.whenYear}\n\n`;
    
    envContent += `# Time range for checking availability (hours)\n`;
    envContent += `HOUR_RANGE_START=${search.hourRangeStart}\n`;
    envContent += `HOUR_RANGE_END=${search.hourRangeEnd}\n\n`;
    
    // Courts - comma-separated list
    const courtNames = search.courts.map(c => c.name).join(',');
    envContent += `# List of courts to monitor (comma-separated)\n`;
    envContent += `COURTS="${courtNames}"\n\n`;
    
    // Court-specific filters (new feature)
    if (search.courts.some(c => c.numbers.length > 0)) {
        envContent += `# Court numbers to filter (JSON format)\n`;
        const courtFilters = {};
        search.courts.forEach(c => {
            if (c.numbers.length > 0) {
                courtFilters[c.name] = c.numbers;
            }
        });
        envContent += `COURT_NUMBERS='${JSON.stringify(courtFilters)}'\n\n`;
    }
    
    // Additional options
    if (search.coveredOnly) {
        envContent += `# Filter for covered courts only\n`;
        envContent += `COVERED_ONLY=true\n\n`;
    }
    
    if (search.twoHours) {
        envContent += `# Look for 2 consecutive hours\n`;
        envContent += `TWO_HOURS=true\n\n`;
    }
    
    envContent += `# Google Chat webhook URL (for GitHub Actions notifications)\n`;
    envContent += `GOOGLE_CHAT_WEBHOOK=\n`;
    
    document.getElementById('envOutput').value = envContent;
    
    // Copy to clipboard
    navigator.clipboard.writeText(envContent).then(() => {
        showMessage('Configuration copied to clipboard!', 'success');
    }).catch(() => {
        showMessage('Configuration generated - please copy manually', 'success');
    });
}

// Local storage functions
function saveSearches() {
    localStorage.setItem('tennisSearches', JSON.stringify(searches));
}

function loadSearches() {
    const stored = localStorage.getItem('tennisSearches');
    if (stored) {
        searches = JSON.parse(stored);
    }
}

// Utility functions
function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

function showMessage(text, type) {
    // Remove existing messages
    const existingMessages = document.querySelectorAll('.success-message, .error-message');
    existingMessages.forEach(msg => msg.remove());
    
    const message = document.createElement('div');
    message.className = type === 'success' ? 'success-message' : 'error-message';
    message.textContent = text;
    
    const firstCard = document.querySelector('.card');
    firstCard.insertBefore(message, firstCard.firstChild);
    
    // Auto-remove after 5 seconds
    setTimeout(() => {
        message.remove();
    }, 5000);
}

// Execute query
async function executeQuery(searchId) {
    const search = searches.find(s => s.id === searchId);
    if (!search) return;
    
    const resultsContainer = document.getElementById(`results-${searchId}`);
    resultsContainer.innerHTML = '<div class="loading">‚è≥ Executing query...</div>';
    
    try {
        // Build API URL
        const apiUrl = 'https://tennis.paris.fr/tennis/jsp/site/Portal.jsp?page=recherche&action=ajax_disponibilite_map';
        
        // Fetch data from API with CORS proxy if available
        const formData = new URLSearchParams();
        formData.append('hourRange', `${search.hourRangeStart}-${search.hourRangeEnd}`);
        formData.append('when', `${search.whenDay}/${search.whenMonth}/${search.whenYear}`);
        
        // Add coating and in/out types
        API_COATING_TYPES.forEach(type => formData.append('selCoating[]', type));
        API_IN_OUT_TYPES.forEach(type => formData.append('selInOut[]', type));
        
        // Try with CORS proxy first, fallback to direct if proxy fails
        let response;
        let rawJson;
        
        if (CORS_PROXY) {
            try {
                // Use CORS proxy with POST data as query parameter
                const fullUrl = `${apiUrl}?${formData.toString()}`;
                const proxiedUrl = `${CORS_PROXY}${encodeURIComponent(fullUrl)}`;
                response = await fetch(proxiedUrl, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json',
                    }
                });
                
                if (response.ok) {
                    rawJson = await response.json();
                }
            } catch (proxyError) {
                console.warn('CORS proxy failed, trying direct request:', proxyError);
                // Fall through to direct request
            }
        }
        
        // If proxy didn't work or wasn't used, try direct request
        if (!rawJson) {
            response = await fetch(apiUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                },
                body: formData.toString()
            });
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            rawJson = await response.json();
        }
        
        // Apply filters
        let filteredResults = filterByFacilities(rawJson, search.courts);
        filteredResults = filterByCourtNumbers(filteredResults, search.courts);
        
        if (search.coveredOnly) {
            filteredResults = filterByCovered(filteredResults);
        }
        
        // Display results
        displayQueryResults(resultsContainer, filteredResults, search);
        
    } catch (error) {
        let errorMessage = escapeHtml(error.message);
        if (error.message.includes('Failed to fetch') || error.message.includes('CORS') || error.message.includes('NetworkError')) {
            errorMessage = 'Unable to connect to tennis.paris.fr API due to CORS restrictions. ' +
                          'Try using a browser extension like "CORS Unblock" or "Allow CORS" to test queries. ' +
                          'Note: The actual listener (main.sh) works correctly as it uses curl which bypasses CORS.';
        }
        resultsContainer.innerHTML = `<div class="error">‚ùå ${errorMessage}</div>`;
    }
}

// Helper to extract facility name from API response
function getFacilityName(feature) {
    return feature.properties.general._nomSrtm;
}

// Helper to extract facility ID from API response
function getFacilityId(feature) {
    return feature.properties.general._id;
}

// Helper to check if facility is available from API response
function isFacilityAvailable(feature) {
    return feature.properties.available;
}

// Filter by facilities
function filterByFacilities(rawJson, courts) {
    const facilityNames = courts.map(c => c.name);
    
    return rawJson.features
        .filter(feature => isFacilityAvailable(feature) && facilityNames.includes(getFacilityName(feature)))
        .map(feature => ({
            facility: getFacilityName(feature),
            facilityId: getFacilityId(feature),
            courts: feature.properties.courts.map(court => ({
                courtNumber: court._formattedAirNum,
                courtName: court._airNom,
                covered: court._airCvt
            }))
        }));
}

// Filter by court numbers
function filterByCourtNumbers(facilities, courtConfigs) {
    return facilities.map(facility => {
        const config = courtConfigs.find(c => c.name === facility.facility);
        
        if (!config || config.numbers.length === 0) {
            return facility;
        }
        
        return {
            ...facility,
            courts: facility.courts.filter(court => config.numbers.includes(court.courtNumber))
        };
    }).filter(facility => facility.courts.length > 0);
}

// Filter by covered courts
function filterByCovered(facilities) {
    return facilities.map(facility => ({
        ...facility,
        courts: facility.courts.filter(court => court.covered === 'V')
    })).filter(facility => facility.courts.length > 0);
}

// Display query results
function displayQueryResults(container, results, search) {
    if (results.length === 0) {
        container.innerHTML = `
            <div class="query-results-content no-results">
                <p>üîç No courts available matching your criteria</p>
            </div>
        `;
        return;
    }
    
    const totalCourts = results.reduce((sum, facility) => sum + facility.courts.length, 0);
    
    let html = `
        <div class="query-results-content">
            <h4>‚úÖ Found ${totalCourts} available court${totalCourts !== 1 ? 's' : ''}</h4>
    `;
    
    results.forEach(facility => {
        html += `
            <div class="facility-result">
                <h5>üéæ ${escapeHtml(facility.facility)}</h5>
                <ul>
        `;
        
        facility.courts.forEach(court => {
            const coveredIcon = court.covered === 'V' ? '‚òÇÔ∏è' : '‚òÄÔ∏è';
            html += `<li>${coveredIcon} Court ${court.courtNumber}: ${escapeHtml(court.courtName)}</li>`;
        });
        
        html += `
                </ul>
            </div>
        `;
    });
    
    html += '</div>';
    
    container.innerHTML = html;
}
